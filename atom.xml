<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寒冬的腊梅</title>
  
  <subtitle>风雨百年6462</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.520xnc.cn/"/>
  <updated>2019-02-14T01:03:16.880Z</updated>
  <id>https://blog.520xnc.cn/</id>
  
  <author>
    <name>xuecx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发量吞吐量响应时间的关系</title>
    <link href="https://blog.520xnc.cn/2019/02/14/20190214084943/"/>
    <id>https://blog.520xnc.cn/2019/02/14/20190214084943/</id>
    <published>2019-02-14T00:49:43.000Z</published>
    <updated>2019-02-14T01:03:16.880Z</updated>
    
    <content type="html"><![CDATA[<p>  在日常工作中经常会听到QPS/TPS这些名词，也会经常被别人问起说你的系统吞吐量有多大。这个问题从业务上来讲，<br>可以理解为应用系统每秒钟最大能接受的用户访问量。或者每秒钟最大能处理的请求数；</p><p>QPS: 每秒钟处理完请求的次数；注意这里是处理完。具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。<br>==可理解为单个接口服务==</p><p>TPS：每秒钟处理完的事务次数，一般TPS是对整个系统来讲的。一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较多。<br>==可理解为一个功能按钮==</p><p>并发量：系统能同时处理的请求数</p><p>RT：响应时间，处理一次请求所需要的平均处理时间</p><p>计算关系：</p><p>QPS = 并发量 / 平均响应时间</p><p>并发量 = QPS * 平均响应时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  在日常工作中经常会听到QPS/TPS这些名词，也会经常被别人问起说你的系统吞吐量有多大。这个问题从业务上来讲，&lt;br&gt;可以理解为应用系统每秒钟最大能接受的用户访问量。或者每秒钟最大能处理的请求数；&lt;/p&gt;
&lt;p&gt;QPS: 每秒钟处理完请求的次数；注意这里是处理完。具体是
      
    
    </summary>
    
    
      <category term="其他" scheme="https://blog.520xnc.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>git配置ssh免密登录</title>
    <link href="https://blog.520xnc.cn/2019/01/31/one/"/>
    <id>https://blog.520xnc.cn/2019/01/31/one/</id>
    <published>2019-01-31T08:04:05.000Z</published>
    <updated>2019-02-18T08:57:56.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-配置免密登录"><a href="#git-配置免密登录" class="headerlink" title="git 配置免密登录"></a>git 配置免密登录</h1><p>1、生成sshkey</p><blockquote><p>ssh-keygen -t rsa -C “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“</p></blockquote><p>注意：如果没有这个命令,找到git中的安装目录  \Git\usr\bin(C:\Program Files\Git\usr\bin)设置环境变量；或者直接在任何目录下右键 选择Git Bash here。</p><h6 id="其中需要输入的地方什么东不填，如果你填了密码，后面会多很多步骤"><a href="#其中需要输入的地方什么东不填，如果你填了密码，后面会多很多步骤" class="headerlink" title="其中需要输入的地方什么东不填，如果你填了密码，后面会多很多步骤"></a>其中需要输入的地方什么东不填，如果你填了密码，后面会多很多步骤</h6><p><img src="https://blog.520xnc.cn/img/ssh.png" alt="Image text"></p><p>2、点击github中我的头像边上的小三角&gt;setting&gt;ssh and GPG keys&gt;new ssh key<br>title可以随便填，key就是我们第一步生成的，key在~/.ssh/id_rsa.pub文件中，复制里面的内容放到key中</p><p>注意：不要加任意的字符，如空格或者回车</p><p>3、验证</p><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xuecx/xuecx.github.io.git</p></blockquote><p>如果能正常克隆代码 就说明成功了。</p><p>文章原始地址：<a href="https://blog.520xnc.cn/2019/01/31/git%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/">https://blog.520xnc.cn/2019/01/31/git%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-配置免密登录&quot;&gt;&lt;a href=&quot;#git-配置免密登录&quot; class=&quot;headerlink&quot; title=&quot;git 配置免密登录&quot;&gt;&lt;/a&gt;git 配置免密登录&lt;/h1&gt;&lt;p&gt;1、生成sshkey&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ssh-key
      
    
    </summary>
    
    
      <category term="git" scheme="https://blog.520xnc.cn/tags/git/"/>
    
      <category term="ssh" scheme="https://blog.520xnc.cn/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>java线上堆栈信息查看</title>
    <link href="https://blog.520xnc.cn/2019/01/31/two/"/>
    <id>https://blog.520xnc.cn/2019/01/31/two/</id>
    <published>2019-01-31T02:40:48.000Z</published>
    <updated>2019-02-18T08:58:11.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jstack查看java堆栈信息"><a href="#jstack查看java堆栈信息" class="headerlink" title="jstack查看java堆栈信息"></a>jstack查看java堆栈信息</h1><p>1、top 查看占用资源多的进程：pid</p><p>2、top -H -p pid  查看对应pid的线程，并找到占用资源多的线程</p><p>3、printf “%x\n” pid 转化为十六进制</p><p>4、在pid.stack中查找对应十六进制的信息</p><p>jstack -l pid &gt; pid.stack，将堆栈信息dump到pid.stack文件中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jstack查看java堆栈信息&quot;&gt;&lt;a href=&quot;#jstack查看java堆栈信息&quot; class=&quot;headerlink&quot; title=&quot;jstack查看java堆栈信息&quot;&gt;&lt;/a&gt;jstack查看java堆栈信息&lt;/h1&gt;&lt;p&gt;1、top 查看占用资源多的
      
    
    </summary>
    
    
      <category term="redis" scheme="https://blog.520xnc.cn/tags/redis/"/>
    
      <category term="其他" scheme="https://blog.520xnc.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
      <category term="Linux" scheme="https://blog.520xnc.cn/tags/Linux/"/>
    
      <category term="堆栈" scheme="https://blog.520xnc.cn/tags/%E5%A0%86%E6%A0%88/"/>
    
      <category term="java" scheme="https://blog.520xnc.cn/tags/java/"/>
    
      <category term="mysql" scheme="https://blog.520xnc.cn/tags/mysql/"/>
    
      <category term="Mongodb" scheme="https://blog.520xnc.cn/tags/Mongodb/"/>
    
      <category term="oracle" scheme="https://blog.520xnc.cn/tags/oracle/"/>
    
      <category term="设计模式" scheme="https://blog.520xnc.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java线程池要点</title>
    <link href="https://blog.520xnc.cn/2018/06/19/20180619105824/"/>
    <id>https://blog.520xnc.cn/2018/06/19/20180619105824/</id>
    <published>2018-06-19T02:58:24.000Z</published>
    <updated>2019-02-19T03:11:08.374Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、线程池框架jdk引入版本"><a href="#一、线程池框架jdk引入版本" class="headerlink" title="一、线程池框架jdk引入版本"></a>一、线程池框架jdk引入版本</h4><p>jdk1.5引入Executor线程池框架，通过它把任务的提交和执行进行解耦，只需要定义好任务，然后提交给线程池，而不用关心该任务是如何执行、被哪个线程执行，以及什么时候执行。</p><h4 id="二、通过Executors类初始化"><a href="#二、通过Executors类初始化" class="headerlink" title="二、通过Executors类初始化"></a>二、通过Executors类初始化</h4><p><strong>newFixedThreadPool()</strong></p><p>说明：初始化一个指定线程数的线程池，其中corePoolSize == maxiPoolSize，使用LinkedBlockingQuene作为阻塞队列</p><p>特点：即使当线程池没有可执行任务时，也不会释放线程。</p><p><strong>newCachedThreadPool()</strong></p><p>说明：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；</p><p>特点：在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。</p><p><strong>newSingleThreadExecutor()</strong></p><p>说明：初始化只有一个线程的线程池，内部使用LinkedBlockingQueue作为阻塞队列。</p><p>特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行；</p><p><strong>newScheduledThreadPool()</strong></p><p>特点：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</p><pre><code>总结</code></pre><p>除了newScheduledThreadPool的内部实现特殊一点之外，其它线程池内部都是基于ThreadPoolExecutor类（Executor的子类）实现的。</p><h4 id="三、ThreadPoolExecutor内部具体实现"><a href="#三、ThreadPoolExecutor内部具体实现" class="headerlink" title="三、ThreadPoolExecutor内部具体实现"></a>三、ThreadPoolExecutor内部具体实现</h4><p><strong>ThreadPoolExecutor类构造器语法形式</strong></p><p>ThreadPoolExecutor（corePoolSize,maxPoolSize,keepAliveTime,timeUnit,<br>workQueue,threadFactory,handle);   </p><p><strong>方法参数：</strong></p><p>corePoolSize：核心线程数</p><p>maxPoolSize：最大线程数</p><p>keepAliveTime：线程存活时间（在corePore&lt;*&lt;maxPoolSize情况下有用<br>    ）</p><p>timeUnit：存活时间的时间单位</p><p>workQueue：阻塞队列（用来保存等待被执行的任务）workQueue参数的取值,JDK提供了4种阻塞队列类型供选择</p><pre><code>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue  SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于ArrayBlockingQuene；PriorityBlockingQuene：具有优先级的无界阻塞队列；</code></pre><p>threadFactory：线程工厂，主要用来创建线程；</p><p>handler：表示当拒绝处理任务时的策略,当线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略</p><pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常;ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常;ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</code></pre><hr><h4 id="四、线程池的状态（5种）"><a href="#四、线程池的状态（5种）" class="headerlink" title="四、线程池的状态（5种）"></a>四、线程池的状态（5种）</h4><p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态</p><p>1、RUNNING：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</p><p>2、SHUTDOWN： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</p><p>3、STOP ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>4、TIDYING ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；</p><p>5、TERMINATED： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；</p><pre><code>线程状态：1. 新建状态(New)：线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()；2. 就绪状态(Runnable)：也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。3. 运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。4. 阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：  (01) 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。  (02) 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。  (03) 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。5. 死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</code></pre><hr><h4 id="五、向线程池提交任务（2种）"><a href="#五、向线程池提交任务（2种）" class="headerlink" title="五、向线程池提交任务（2种）"></a>五、向线程池提交任务（2种）</h4><pre><code>Executor.execute(Runnable command);ExecutorService.submit(Callable&lt;T&gt; task);</code></pre><p><strong>execute()内部实现</strong></p><p>1.首次通过workCountof()获知当前线程池中的线程数，如果小于corePoolSize,就通过addWorker()创建线程并执行该任务；否则，将该任务放入阻塞队列；</p><p>2.如果能成功将任务放入阻塞队列中,如果当前线程池是非RUNNING状态，则将该任务从阻塞队列中移除，然后执行reject()处理该任务；如果当前线程池处于RUNNING状态，则需要再次检查线程池（因为可能在上次检查后，有线程资源被释放），是否有空闲的线程；如果有则执行该任务；</p><p>3.如果不能将任务放入阻塞队列中,说明阻塞队列已满；那么将通过addWoker()尝试创建一个新的线程去执行这个任务；如果addWoker()执行失败，说明线程池中线程数达到maxPoolSize,则执行reject()处理任务；</p><p><strong> sumbit()内部实现</strong></p><p>会将提交的Callable任务会被封装成了一个FutureTask对象,FutureTask类实现了Runnable接口，这样就可以通过Executor.execute()提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法； </p><p><strong>比较：</strong></p><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。 </p><hr><h4 id="六、线程池的关闭（2种）"><a href="#六、线程池的关闭（2种）" class="headerlink" title="六、线程池的关闭（2种）"></a>六、线程池的关闭（2种）</h4><pre><code>ThreadPoolExecutor提供了两个方法shutdown()shutdownNow()</code></pre><p>　　</p><p>1、shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务；</p><p>2、shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p><hr><h4 id="七、线程池容量的动态调整"><a href="#七、线程池容量的动态调整" class="headerlink" title="七、线程池容量的动态调整"></a>七、线程池容量的动态调整</h4><pre><code>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()setMaximumPoolSize()</code></pre><h4 id="八、总结："><a href="#八、总结：" class="headerlink" title="八、总结："></a>八、总结：</h4><p>1、线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务；</p><p>2、如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、线程池框架jdk引入版本&quot;&gt;&lt;a href=&quot;#一、线程池框架jdk引入版本&quot; class=&quot;headerlink&quot; title=&quot;一、线程池框架jdk引入版本&quot;&gt;&lt;/a&gt;一、线程池框架jdk引入版本&lt;/h4&gt;&lt;p&gt;jdk1.5引入Executor线程池框架，
      
    
    </summary>
    
    
      <category term="线程池" scheme="https://blog.520xnc.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>redis实现分布式锁解析</title>
    <link href="https://blog.520xnc.cn/2018/04/10/20180410152236/"/>
    <id>https://blog.520xnc.cn/2018/04/10/20180410152236/</id>
    <published>2018-04-10T07:22:36.000Z</published>
    <updated>2019-02-19T08:39:21.347Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁其实可以理解为：控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.redis.tool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:xuecx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@descript</span>:&lt;p&gt;利用redis实现分布式锁&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:2018/10/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate redis连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey       锁名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retry         从试次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId     请求id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire        过期时间 单位s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(RedisTemplate redisTemplate, String lockKey, Integer retry, String requestId, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; retry; i++) &#123;</span><br><span class="line">            <span class="comment">//如果键不存在则新增,存在则不改变已经有的值</span></span><br><span class="line">            Boolean hasLock = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId);</span><br><span class="line">            <span class="keyword">if</span> (hasLock) &#123;</span><br><span class="line">                <span class="comment">//设置过期时间</span></span><br><span class="line">                redisTemplate.expire(lockKey, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁,支持集群和单机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey       锁名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId     请求id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(RedisTemplate redisTemplate, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        String UNLOCK_LUA=<span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        List&lt;String&gt; lockKeys = Collections.singletonList(lockKey);</span><br><span class="line">        List&lt;String&gt; requestIds = Collections.singletonList(requestId);</span><br><span class="line">        RedisCallback&lt;Long&gt; callback = (RedisConnection connection) -&gt; &#123;</span><br><span class="line">            Object nativeConnection = connection.getNativeConnection();</span><br><span class="line">            <span class="comment">// 集群模式和单机模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行</span></span><br><span class="line">            <span class="comment">// 集群模式</span></span><br><span class="line">            <span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> JedisCluster) &#123;</span><br><span class="line">                <span class="keyword">return</span> (Long) ((JedisCluster) nativeConnection).eval(UNLOCK_LUA,lockKeys, requestIds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单机模式</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> Jedis) &#123;</span><br><span class="line">                <span class="keyword">return</span> (Long) ((Jedis) nativeConnection).eval(UNLOCK_LUA, lockKeys, requestIds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        Long result = (Long) redisTemplate.execute(callback);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般情况上述分布式锁已经能满足很多场景了，</p><p>但是特殊情况，在 ==if (hasLock) {== 行的时候，系统挂了，那么就死锁了；</p><p>原因是加锁的地方不是原子操作。</p><p>将代码改进<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> redisTemplate redis连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey       锁名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> retry         从试次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestId     请求id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expire        过期时间 单位s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(RedisTemplate redisTemplate, String lockKey, Integer retry, String requestId, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RedisCallback&lt;String&gt; stringRedisCallback = <span class="keyword">new</span> RedisCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConnection)</span> </span>&#123;</span><br><span class="line">                    JedisCommands nativeConnection = (JedisCommands) redisConnection.getNativeConnection();</span><br><span class="line">                    <span class="keyword">return</span> nativeConnection.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"PX"</span>, expire);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            String execute = (String) redisTemplate.execute(stringRedisCallback);</span><br><span class="line">            <span class="keyword">return</span> !execute.isEmpty();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; retry) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1、锁过期了业务还没有完成怎么办？</p><p>目前只能通过对业务的测试，找到一个最大的业务执行时间，然后设置一个最大的业务执行时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式锁其实可以理解为：控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性。 &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="redis" scheme="https://blog.520xnc.cn/tags/redis/"/>
    
      <category term="分布式锁" scheme="https://blog.520xnc.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>谈谈自己对spring的理解</title>
    <link href="https://blog.520xnc.cn/2018/03/18/20180318095425/"/>
    <id>https://blog.520xnc.cn/2018/03/18/20180318095425/</id>
    <published>2018-03-18T01:54:25.000Z</published>
    <updated>2019-02-19T01:57:05.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、spring的理解"><a href="#一、spring的理解" class="headerlink" title="一、spring的理解"></a>一、spring的理解</h3><p>1、spring 是一个大概念，开始是一个library到现在的一个系列；</p><p>2、spring现在最主要的内容是spring Framework、spring data、spring security、spring Batch，快速框架 spring boot，微服务架构spring cloud，其中最主要的是springFramework，它包含了IoC、AOP、MVC以及Testing；</p><p>3、Spring 的核心就是IoC和AOP，IoC就是依赖注入，简言之就是将对象的创建交由Spring容器，由原来的编译时延迟到运行时，及是通过配置进行加载，这样一来就解决了不用编译，后期选择具体的实现，本身也是面向对象的核心理念。简言之就是从原先的new 变为配置组装，内部通过注入解决依赖关系；</p><p>4、AOP就是面向切面编程，使用最多的就是事物（动态代理，invokationHandler-jdk、MethodInterceptor-cglib ）、记录日志，自己写AOP的话就利用@aspect 和@pointcut</p><h3 id="二、Spring-最有价值的应用："><a href="#二、Spring-最有价值的应用：" class="headerlink" title="二、Spring 最有价值的应用："></a>二、Spring 最有价值的应用：</h3><p>1、Ioc和AOP就是一个套路，spring 用这个套路集成了多个orm，所以spring 越做越大，慢慢就形成了 spring way；</p><p>2、spring的实践应用，spring mvc、spring data、spring Security、Spring boot、spring cloud等</p><h3 id="三、spring-mvc的运行流程"><a href="#三、spring-mvc的运行流程" class="headerlink" title="三、spring mvc的运行流程"></a>三、spring mvc的运行流程</h3><p>1、用户发送请求到前端控制器DispatcherServlet；</p><p>2、DispatcherServlet收到请求调用HandlerMapping 处理器映射器；</p><p>3、处理器映射器通过xml配置或者注解找到对应的处理器，并生成处理器对象以及处理器拦截器（如果有），并返回给DispacherSersvlet；</p><p>4、DispacherSersvlet调用HandlerAdapter适配器；</p><p>5、HandlerAdapter 经过适配后调用具体的后端Controller；</p><p>6、Controller完成后返回ModelAndView给HandlerAdapter;</p><p>7、HandlerAdapter返回给DispatcherServlet；</p><p>8、DispatcerServlet 传递给ViewReslover视图解析器；</p><p>9、视图解析器返回View给DispatcherServlet；</p><p>10、DispatcherServlet 根据view 渲染视图，响应用户；</p><h3 id="四、Spring-data"><a href="#四、Spring-data" class="headerlink" title="四、Spring data"></a>四、Spring data</h3><p>1、包含了很多子项目，有commons，jpa，jdbc，Document、key-value等，他不拘礼与关系型数据库还是非关系型数据库，只在简化数据持久化操作，他提供了对数据库crud的操作方法，降低了数据访问对象的开发量；</p><h3 id="五、spring-Security"><a href="#五、spring-Security" class="headerlink" title="五、spring Security"></a>五、spring Security</h3><p>Spring Security是基于spring ioc和Aop为企业级应用提供安全控制的解决方案，减少企业级应用中开发大量的重复的安全代码；</p><p>1、 Web/Http 安全：这是最复杂的部分。通过建立 filter 相关的 service bean 来实现框架的认证机制</p><p>2、业务对象或者方法的安全：控制方法访问权限的。</p><p>3、AuthenticationManager：处理来自于框架其他部分的认证请求。</p><p>4、为 Web 或方法的安全提供访问决策；</p><p>5、AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。</p><p>6、UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。</p><h4 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h4><p>1、shiro 提供了用户认证、权限认证、session管理、加密、记住我、cache、Testing，web集成，多线程应用的并发验证；</p><p>2、shiro三大核心Subject, SecurityManager 和 Realms</p><p>spring Security和shiro的比较：<br>Shiro比Spring更容易使用，实现和最重要的理解<br>Spring Security更加知名的唯一原因是因为品牌名称<br>“Spring”以简单而闻名，但是很多人发现安装Spring Security很难<br>然而，Spring Security设置支持更好<br>Apache Shiro在Spring Security处理密码学方面有一个额外的模块<br>Spring-security 对spring 结合较好，如果项目用的springmvc ，使用起来很方便。但是如果项目中没有用到spring，那就不要考虑它了。<br>Shiro 功能强大、且 简单、灵活。是Apache 下的项目，比较可靠，且不跟任何的框架或者容器绑定，可以独立运行；</p><h3 id="六、spring-Batch"><a href="#六、spring-Batch" class="headerlink" title="六、spring Batch"></a>六、spring Batch</h3><p>1、批处理框架，大型企业应用中批量下发命令；</p><h3 id="七、spring-boot"><a href="#七、spring-boot" class="headerlink" title="七、spring boot"></a>七、spring boot</h3><p>开发目的是简化spring的配置和开发过程，框架使用了特定的配置，从而使开发人员不必在关注很多spring 模板化的配置，他致力于快速应用开发领域；</p><ol><li>创建独立的Spring应用程序</li><li>嵌入的Tomcat，无需部署WAR文件</li><li>简化Maven配置</li><li>自动配置Spring</li><li>提供生产就绪型功能，如指标，健康检查和外部配置;</li></ol><h3 id="八、spring-cloud"><a href="#八、spring-cloud" class="headerlink" title="八、spring cloud"></a>八、spring cloud</h3><p>Spring Cloud是一个基于Spring Boot来实现的一系列工具框架的集合体，Spring Cloud为开发人员提供了快速构建分布式系统中的一些通用模式（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，群集状态）， 它们可以在任何分布式环境中正常工作，包括开发人员自己的笔记本电脑，裸机数据中心和受管平台；</p><p>1、 服务发现——Netflix Eureka ：一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端；</p><p>2、客服端负载均衡——Netflix Ribbon  ：主要提供客户侧的软件负载均衡算法；</p><p>3、断路器——Netflix Hystrix： 断路器可以防止一个应用程序多次试图执行一个操作，即很  可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久 的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正​​，应用程序可以尝试调用操作；</p><p>4、 服务网关——Netflix Zuul  ：类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性；</p><p>5、 分布式配置——Spring Cloud Config；</p><p>……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、spring的理解&quot;&gt;&lt;a href=&quot;#一、spring的理解&quot; class=&quot;headerlink&quot; title=&quot;一、spring的理解&quot;&gt;&lt;/a&gt;一、spring的理解&lt;/h3&gt;&lt;p&gt;1、spring 是一个大概念，开始是一个library到现在的一个
      
    
    </summary>
    
    
      <category term="spring" scheme="https://blog.520xnc.cn/tags/spring/"/>
    
      <category term="srpingboot" scheme="https://blog.520xnc.cn/tags/srpingboot/"/>
    
      <category term="springcloud" scheme="https://blog.520xnc.cn/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis高级用法</title>
    <link href="https://blog.520xnc.cn/2015/04/20/20150420144522/"/>
    <id>https://blog.520xnc.cn/2015/04/20/20150420144522/</id>
    <published>2015-04-20T06:45:22.000Z</published>
    <updated>2019-02-20T07:03:00.487Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目需要，研究了一下mybatis，在学习过程中记录下了其中的几个重要的用法，本文例子主要说了foreach、非空更新、插入数据时如何返回主键id， on duplicate key update的用法，其他的等有空再写吧。</p><p><strong>1、Foreach</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=<span class="string">"deleteIfNotExist"</span> parameterType=<span class="string">"java.util.List"</span>&gt;</span><br><span class="line">    DELETE  FROM bd_article_tag_map</span><br><span class="line">    WHERE article_id=#&#123;articleId&#125;</span><br><span class="line">    AND article_tag_id NOT IN</span><br><span class="line">    &lt;foreach item=<span class="string">"item"</span> index=<span class="string">"index"</span> collection=<span class="string">"list"</span> open=<span class="string">"("</span> separator=<span class="string">","</span> close=<span class="string">")"</span>&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><br><strong>2、非空更新</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateByArticleId"</span> parameterType=<span class="string">"com.iss.blog.po.Article"</span>&gt;</span><br><span class="line">    UPDATE ub_article</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"articleTitle!=null"</span>&gt;</span><br><span class="line">            article_title =#&#123;articleTitle&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"articleSummary!=null"</span>&gt;</span><br><span class="line">            article_summary=#&#123;articleSummary&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"articleClick!=-1"</span>&gt;</span><br><span class="line">            article_click=#&#123;articleClick&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    WHERE article_id=#&#123;articleId&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><br><strong>3、插入字段后返回自增主键的值</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"insert"</span> parameterType=<span class="string">"com.iss.blog.po.Article"</span> useGeneratedKeys=<span class="string">"true"</span> keyProperty=<span class="string">"article.articleId"</span>&gt;</span><br><span class="line">    INSERT INTO ub_article</span><br><span class="line">    (article_id,......</span><br><span class="line">    article_create_time,article_modify_time</span><br><span class="line">    )</span><br><span class="line">    VALUES (#&#123;article.articleId&#125;,#&#123;article.userId&#125;,......</span><br><span class="line">    #&#123;article.articleCreateTime,jdbcType=TIMESTAMP&#125;, #&#123;article.articleModifyTime,jdbcType=TIMESTAMP&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>设置useGeneratedKeys=”true”并且制定主键keyProperty；这样在插入成功后就会调用keyProperty的setter方法回填主键。注意，必须加上@Param，否则会报错。<br>插入成功返回成功操作的条目数；失败返回 0</p></blockquote><p><strong>4、不存在插入，存在更新</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">INSERT INTO <span class="title">car_brand</span> <span class="params">(brand_id, initial,name ,create_time,update_time)</span></span></span><br><span class="line"><span class="function">        VALUES</span></span><br><span class="line"><span class="function">        &lt;foreach collection</span>=<span class="string">"carTypes"</span> separator=<span class="string">","</span> item=<span class="string">"item"</span>&gt;</span><br><span class="line">            (#&#123;item.id&#125;, #&#123;item.groupName&#125;,#&#123;item.name&#125;,now(),NULL)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">        on duplicate key update</span><br><span class="line">        name=values(name),</span><br><span class="line">        initial=values(initial),</span><br><span class="line">        update_time=now()</span><br></pre></td></tr></table></figure></p><blockquote><p>注意关键字on duplicate key update ,其中name,initial必须有一个是唯一索引</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目需要，研究了一下mybatis，在学习过程中记录下了其中的几个重要的用法，本文例子主要说了foreach、非空更新、插入数据时如何返回主键id， on duplicate key update的用法，其他的等有空再写吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、Forea
      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://blog.520xnc.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>认识javajvm以及jvm中的一些概念</title>
    <link href="https://blog.520xnc.cn/2013/08/10/20130810161455/"/>
    <id>https://blog.520xnc.cn/2013/08/10/20130810161455/</id>
    <published>2013-08-10T08:14:55.000Z</published>
    <updated>2019-02-20T08:33:48.044Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、jvm大事记"><a href="#一、jvm大事记" class="headerlink" title="一、jvm大事记"></a>一、jvm大事记</h4><blockquote><p>使用最为广泛的JVM为HotSpot</p></blockquote><p>HotSpot 为Longview Technologies开发 被SUN收购</p><p>2006年 Java开源 并建立OpenJDK</p><p>HotSpot  成为Sun JDK和OpenJDK中所带的虚拟机</p><p>2008 年 Oracle收购BEA得到JRockit VM</p><p>2010年Oracle 收购 Sun    得到Hotspot</p><p>Oracle宣布在JDK8时整合JRockit和Hotspot，优势互补,在Hotspot基础上，移植JRockit优秀特性</p><h4 id="二、jvm的启动流程"><a href="#二、jvm的启动流程" class="headerlink" title="二、jvm的启动流程"></a>二、jvm的启动流程</h4><p><img src="http://pm8ml1daf.bkt.clouddn.com/blog/jvm%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="Image text"><br>jvm的启动流程图</p><h4 id="三、jvm的构成"><a href="#三、jvm的构成" class="headerlink" title="三、jvm的构成"></a>三、jvm的构成</h4><blockquote><p>jvm由类加载系统，内存空间中的方法区、堆栈、本地方法栈、pc寄存器、垃圾回收器、pc寄存器、执行引擎本地方法库构成。下图是jvm的构成图</p></blockquote><p><img src="http://pm8ml1daf.bkt.clouddn.com/blog/jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="Image text"><br>jvm的构成图</p><h5 id="3-1-PC寄存器"><a href="#3-1-PC寄存器" class="headerlink" title="3.1 PC寄存器"></a>3.1 PC寄存器</h5><blockquote><p>每个线程拥有一个PC寄存器,在线程创建时 创建,指向下一条指令的地址,执行本地方法时，PC的值为undefined</p></blockquote><h5 id="3-2方法区"><a href="#3-2方法区" class="headerlink" title="3.2方法区"></a>3.2方法区</h5><blockquote><p>保存装载的类信息（类型的常量池，字段，方法信息，方法字节码），一般和永久区(Perm)关联在一起，</p></blockquote><blockquote><p>++JDK6时，String等常量信息置于方法,JDK7时，已经移动到了堆++</p></blockquote><h5 id="3-3java堆"><a href="#3-3java堆" class="headerlink" title="3.3java堆"></a>3.3java堆</h5><blockquote><p>它和程序开发密切相关，应用系统对象都保存在Java堆中，所有线程共享Java堆，对分代GC来说，堆也是分代的，它GC的主要工作区间</p></blockquote><table><thead><tr><th>eden</th><th>s0</th><th>s1</th><th>tenured  </th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>上图是堆由新生代到老年代的复制算法</p><h5 id="3-4-java栈"><a href="#3-4-java栈" class="headerlink" title="3.4 java栈"></a>3.4 java栈</h5><blockquote><p>线程私有，栈由一系列帧组成（因此Java栈也叫做帧栈），帧保存一个方法的局部变量、操作数栈、常量池指针，每一次方法调用创建一个帧，并压栈。</p></blockquote><blockquote><p>栈上分配：小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上，直接分配在栈上，可以自动回收，减轻GC压力<br>大对象或者逃逸对象无法栈上分配</p></blockquote><p>问题 为了能让递归函数调用次数多些，应该怎么做？</p><blockquote><p>答案是增大栈内存</p></blockquote><h5 id="3-5java-内存模型"><a href="#3-5java-内存模型" class="headerlink" title="3.5java 内存模型"></a>3.5java 内存模型</h5><p>当数据从主内存复制到工作存储时，必须出现两个动作：第一，由主内存执行的读（read）操作；第二，由工作内存执行的相应的load操作；当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作</p><p><img src="http://pm8ml1daf.bkt.clouddn.com/blog/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="image"></p><ul><li>每一个操作都是原子的，即执行期间不会被中断</li><li>对于普通变量，一个线程中更新的值，不能马上反应在其他变量中</li><li><p>如果需要在其他线程中立即可见，需要使用 volatile 关键字</p><pre><code>volatile 关键字修饰的变量，内存模型中体现如下图</code></pre></li></ul><p><img src="http://pm8ml1daf.bkt.clouddn.com/blog/vlote.png" alt="image"></p><blockquote><p>volatile 不能代替锁,一般认为volatile 比锁性能好（不绝对）</p></blockquote><p><strong>volatile的作用</strong></p><p>1、保证变量的可见性（一个线程修改了变量，其他线程可以立即知道）;  </p><blockquote><p>保证可见性的其他方法: synchronized，final</p></blockquote><p>2、有序性</p><p>3、指令重排</p><p><strong>指令重排的基本原则</strong></p><ul><li>程序顺序原则：一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写，先发生于读</li><li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li><li>传递性：A先于B，B先于C 那么A必然先于C</li><li>线程的start方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结（Thread.join()）</li><li>线程的中断（interrupt()）先于被中断线程的代码</li><li>对象的构造函数执行结束先于finalize()方法</li></ul><p>有写得不对的地方请大神多指教，转载请注明出处</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、jvm大事记&quot;&gt;&lt;a href=&quot;#一、jvm大事记&quot; class=&quot;headerlink&quot; title=&quot;一、jvm大事记&quot;&gt;&lt;/a&gt;一、jvm大事记&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;使用最为广泛的JVM为HotSpot&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
    
      <category term="jvm" scheme="https://blog.520xnc.cn/tags/jvm/"/>
    
  </entry>
  
</feed>
